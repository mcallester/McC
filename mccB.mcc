#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <math.h>
#include <setjmp.h>
#include <time.h>
#include <dlfcn.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/file.h>
#include <fcntl.h>

#include "mcc.h"

expptr casecode1(expptr,expptr,expptr);
expptr casecode1a(expptr,expptr,expptr,expptr);
expptr casecode2(expptr,expptr,expptr);
expptr constructor_code(char c);

void case_error(){
  berror("unrecognized syntax ");
}

/** =============================================
pattern matching.

the syntax for ucase is

ucase{<expresson>;
   {<pattern1>}:{<statement>}
   ...
   {<atternk>}:{<statementk>}}

Statements can be in brackets or terminated with semicolon.
================================================= **/

expptr ucase_macro(expptr e){
  if(constructor(e) != 'A' || constructor(arg2(e)) != '{')case_error();
  expptr arglist = arg1(arg2(e));
  if(constructor(arglist) != 'O' || arg1(arglist) != semiop)case_error();
  expptr topexp = op_arg1(arglist);
  expptr rules = op_arg2(arglist);
  expptr donelabel = gensym(`{done});
  expptr topvar = gensym(`{top});
  return `{{expptr ${topvar} = ${topexp};
    ${casecode1(rules, topvar, donelabel)}
    ${donelabel}: ;}};
}

expptr casecode1(expptr rules, expptr topvar, expptr donelabel){
  if(rules == NULL)return `{case_error();};
  if(constructor(rules) != 'O')case_error();
  expptr  op = arg1(rules);
  expptr rule,rest;
  if(op == spaceop){
    rule = op_arg1(rules);
    rest = op_arg2(rules);}
  else if(op == colonop){
    rule = rules;
    rest = NULL;}
  else case_error();
  if(constructor(rule) != 'O' || arg1(rule) != colonop || constructor(op_arg1(rule)) != '{' || constructor(op_arg2(rule)) != '{')case_error();
  expptr pattern = arg1(op_arg1(rule));
  expptr body = arg1(op_arg2(rule));
  expptr elseform = casecode1(rest,topvar,donelabel);
  return(`{${casecode2(cons(cons(pattern,topvar),NULL),
		       macroexpand(body),
		       donelabel)}
      ${elseform}});
}

expptr casecode2(expptr pairs, expptr body, expptr donelabel){
  if(pairs==NULL)return`{${body} ; goto ${donelabel} ;};
  expptr restpairs = cdr(pairs);
  expptr thispair = car(pairs);
  expptr pattern = car(thispair);
  expptr valvar = cdr(thispair);
  if(pattern == NULL)return `{if(${valvar} == NULL){${casecode2(restpairs,body,donelabel)}}};
  char c = constructor(pattern);
  if(c == '!'){
    expptr var = arg1(pattern);
    if(var == NULL)case_error();
    return(`{expptr ${var} = ${valvar};${casecode2(restpairs,body,donelabel)}});}
  if(c == 'a' || c == 'o' || string_quotep(c))return `{if(${valvar} == ${quote_code(pattern)}){${casecode2(restpairs,body,donelabel)}}};
  expptr left = gensym(`{leftval});
  expptr right = gensym(`{rightval});
  return `{if(constructor(${valvar}) == ${constructor_code(c)}){
      expptr ${left} = arg1(${valvar});
      expptr ${right} = arg2(${valvar});
      ${casecode2(cons(cons(arg1(pattern),left), cons(cons(arg2(pattern),right), restpairs)),
		  body,
		  donelabel)}}};
}

void mccB_init(){
  set_macro(`{ucase},ucase_macro);
}
