\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{psfrag}

\newcommand{\mtt}[1]{\mbox{\tt #1}}
\input /users/davidmcallester/03/tex/nofill.tex

\newcommand{\ignore}[1]{}

\parskip = 2ex
\newcommand{\context}{\text{\emph{context}}}

\title{MetaC}
\author{David McAllester}

\begin{document}
\maketitle

\section{Motivation}

\bigskip
\bigskip
MetaC is a C extension supporting the symbolic programming features of Lisp and the interactive programming environment and notebook support of scripting languages such as Python.

The fundamental language features of interest are pattern matching\footnote{Pattern matching is not a feature of Lisp but is easily implemented given backquote and computed macros},
backquote and computed macros. Pattern matching is familiar in many languages.  Backquote is a generalization of Lisp quotation supporting
the insertion of computed values into the quoted expression. Backquote will be familiar to
those versed in writing Lisp computed macros. Pattern matching and backquote together allow one to directly express rewriting. But simple rewriting is a special and trivial case of computed macro expansion.
Computed macros allow arbitrary source code (Lisp code in the case of Lisp) to be
used in computing the expansion of a macro.  Computed macros should be viewed as compilers.  A computed macro can do
sophisticated type inference or data-flow analysis as part of macro expansion.

Packages of computed macros are often used as compilers for sophisticated languages.  However, given that one is writing a compiler, C is a more reasonable target language than Lisp or high level scripting languages.
Experience with Lisp indicates that for computed macros to work smoothly it is important that the source language be the same as the target language.  The target, and hence the source, should be C.

\section{Universal Algebraic Syntax (UAS)}

It is not obvious how to implement light weight expression quotation and expression pattern matching for C expressions.  The syntax of C is complex.  We bypass this complexity by introducing universal algebraic syntax (UAS).
UAS is a compromise between the extreme syntactic simplicity of Lisp and the desire for a syntax that is more similar to C.
While not as minimal as Lisp, UAS is still simple --- there are seven syntactic categories including a category for the null expression.
UAS is universal in that the syntactic trees are considered to be semantics-free and, more importantly, under very weak assumptions a semantics defined by a compiler on strings
can be transferred to UAS trees.
This later property is made possible by ensuring that the UAS reader will accept any parenthesis-balanced string
and that the process of reading a string into a UAS expression can be inverted --- printing the expression recovers the original string.
A semantics defined by a compiler on strings can be imposed on UAS expressions simply by printing the expressions and applying the compiler to the resulting strings.

The MetaC reader converts character strings to semantics-free syntax trees (expressions).
The MetaC reader first preprocessing the input string to remove C-style comments.
The preprocessor also divides file character strings (as opposed to REPL inputs) into top level segments.
A segment starts at the beginning of any nonempty line whose first character is not a space or tab and where the preceding line is empty.
A segment also starts at the begining of any line beginning with the character {\bf \#} (indicating a C preprocessor line).
The file must be parenthesis-balanced within each segment.  This means that every open parenthesis, brace or bracket has a matching closing character and that string quotations
are properly closed.  The reader also has the property that white space is ignored other than in the determining the top level segmentation and in separating symbols.
The reader converts each segment to a single expression.
An expression is defined recursively to one of the following.

\begin{itemize}
\item A symbol.  A symbol represents a string of alpha-numeric characters (upper and lower case letters of the alphabet, plus the decimal numerals, plus underbar).
  For example {\bf  foo\_bar1}.
\item A tagged symbol.  A tagged symbol consists of a symbol-tag followed by a symbol.  The symbol tag characters are {\bf \$}, {\bf $\backslash$}, {\bf `}, {\bf !}, {\bf ?}, {\bf \#} and {\bf \%}.
  For example we have the tagged symbols {\bf ?foo} and {\bf !foo}.
\item A quoted string.  For example {\bf \tt "!:\&?;"} or {\tt 'a'}.  In UAS there is no distinction between {\bf "foo"} and {\bf 'foo'}.  To avoid confusion newline characters are not allowed in strings (the two character sequence {\bf /n} is ok).
\item A parenthesis expression.  This is an expression of the form ($e$), $\{e\}$, or $[e]$ where $e$ is an expression.  In MetaC $(e)$ is always a different expression from $e$.
\item An application expression.  This is a structured symbol followed by a parenthesis expression.  For example {\bf foo(x)}.
The binding of structured symbols to parenthesis expressions to form application expressions is tighter than (higher precedence than) the formation of binary connective expressions.
\item A binary connective expression.  For example {\bf x=3} is the binary connective expression with connective {\bf =} and symbol arguments {\bf x} and {\bf 3}.  Binary conectives are described in more detail below.
\item The null expression and the null connective. In order to ensure that the UAS reader can read any parenthesis-balanced string we can use the null
  expression as arguments and the null connective to combine pairs of adjacent expressions.  This is described in more detail below.
\end{itemize}

{\bf Binary connectives.} The binary connectives consist of all non-empty strings over the characters {\bf ;}, comma, \{{\bf =}, {\bf $\sim$}, {\bf <}, {\bf >}\}, \{\mtt{|}, {\bf \&}\}, \{{\bf +},
{\bf -}\}, \{{\bf *}, {\bf /}\}, {\bf .}, {\bf @}, and \mtt{$\hat{~}$}.
Single-character connectives are outermost to innermost in the order given (low
precedence to high precedence) where set brackets indicate same-precedence.    All binary connectives are infix.  The last four single-chracter connectives are left-associative and the
others are right-associative. For example {\bf f(x).a.b} reads as {\bf f(x).a} and {\bf b} connected with dot.  Multi-character connectives are
innermost to (higher precedence than) all single character binary connectives except {\bf :} which is the innermost binary connective. All multi-character binary connectives have the same
precedence which is higher precedence (innermost) to all single character connectives other than {\bf :}.  Multi-character connectives are left associative.  The null connective is right associative and is outermost to (lower precedence) than all other binary connectives
except {\bf;} and comma --- the null connective binds more tightly than comma (this causes argument lists to have a friendly tree structure).

{\bf Null arguments and the null connective.}  We can draw expressions as trees where null arguments and connectives are drawn as empty nodes.
For example {\bf (foo bar)} is a the expression.
\begin{verbatim}
   ( )

    |
      
  /   \
foo   bar
\end{verbatim}
  
{\bf \{x=1;y=2;\}} is the expression
\begin{verbatim}
   { }
    |
    ;   
  /    \
 =       ;
/ \     / \
x  1   =
      / \
     y   2
\end{verbatim}
{\bf \{?=\}} is  the expression
\begin{verbatim}
   { }
    |

  /   \
 ?     =
 |   /   \
\end{verbatim}
Since any parenthesis-balanced string reads as an expression, we can think of expressions as structured representations of strings.

\section{Pattern Matching}

MetaC provides a pattern matching case statement.
The general form of the case construct is the following.
$${\bf ucase(e; \{<pattern1>\}:\{<statement1>\}; ... ;\{<patternn>\}:\{<statementn>\})}$$
Variables are marked in patterns by {\bf"!"}. For example we might write the following.

\begin{code}
int value(exp e)\{
  ucase(e;
   \{!x+!y\}:\{return value(x)+value(y);\};
   \{!x*!y\}:\{return value(x)*value(y);\};
   \{(!x)\}:\{return value(x);\};
   \{!z\}:\{return symbol\_int(z)]);\})
\}
\end{code}

In many cases the choice of the particular tree structure imposed by the MetaC reader is unimportant.  For example, the expression {\bf a+b+c} will match the pattern
{\bf !x+!y+!z} independent of whether + is left associative or right associative.  But the tree structure does matter in other cases.  The pattern {\bf !x*!y}
will not match the string {\bf a+b*c} because {\bf +} is above (outer to) {\bf *} in the parse tree constructed by MetaC. Note that the pattern {\bf !x*!y} does match {\bf (a+b)*c}.

Structured symbols are expressions with tree structure.  The pattern {\bf !x:gritch} matches the structured symbol {\bf foo:bar:gritch} with {\bf x} bound to the structured symbol {\bf foo:bar}.

\section{Backquote}

MetaC provides Lisp-style backquote.
In the simplest case {\bf `\{$e$\}} evaluates to a data structure which is the UAS syntax tree for
the string $e$.  For example, the MetaC expression {\bf `\{a+b+c\}}
evaluates to the expression {\bf a+b+c}.

Backquote can also be used for pattern instantiation.
When computing the value of {\bf `\{$e$\}} suexpression of $e$ of the form {\bf \$$w$} are replaced by the value of the expression $w$.
For example consider the following expression.
\begin{equation}
\label{bq1}
`\{a+b+\$z\}
\end{equation}
If the value of variable {\bf z} is the expression {\bf c} then the value of expression (\ref{bq1}) is the expression {\bf a+b+c}.

Structured symbols are expressions and structured symbols can be constructed by substitution into parts of the symbol.
For example, if {\bf x} is bound to {\bf foo} then {\bf `\{\$x:bar\}} evaluates to the structures symbol {\bf foo:bar}.

We allow for expression evaluation inside backquote by writing applications of {\bf \$}.  For example if the procedure call {\bf f(x)} evaluates to the symbol {\bf world} then
{\bf `\{hello \$\{f(x)\})\}} evaluates to {\bf hello world}.

The unary operator {\bf \$} can be included in an expression constant by quoting it as in the following.
\begin{equation}
\label{bq2}
`\{`\{a + \$y + \backslash\$z\}\}
\end{equation}
If the value of variable {\bf y} is the expression $b$ then the value expression of (\ref{bq2}) is expression (\ref{bq1}).
Quotation expression can be included in the expression by adding another layer of quotation as in the following.
\begin{equation}
\label{bq3}
`\{`\{`\{\$x + \backslash\$y + \backslash\backslash\$z\}\}\}
\end{equation}
If the value of variable {\bf x} is the expression {\bf a} then the value of expression (\ref{bq3}) is expression (\ref{bq2}).


\section{The MetaC Pretty Printer}

The printer converts an abstract syntax tree back into a byte string which includes newline bytes and space characters
so that the expression is well formatted. The printer inverts the reader up to string equivalence (as defined by the reader).
This emphasizes that we are thinking of the abstract syntax tree as a representation of a character string.

\section{Reader-Printer Inverse Properties}

The white space characters are space, tab and newline.  White space characters are generally ignored.  There are two exceptions to this.
First, white space between two alpha-numeric characters (upper and lower case letters and the numberals 0 to 9) causes two symbols to be read rather than one.
Second, a newline that is not preceded by the quotation character '//' and is not followed by a white space character is
treated as a file segment terminator.  Parentheses must be balanced within each file segments.

For any character string we define the white space normal form of $s$
to be the result of removing all c-style comments and then removing all white space characters except for
a single space character between two alpha-numeric characters and where segment terminator newlines
are replaced by null bytes.

The reader has the property that if string $s$ and $s'$ have the same white space normal form then the result of reading
$s$ is the same as the result of reading $s'$.  The printer inverts the reader
in the sense that reading a string $s$ and then prining the result to get string $s'$ has the property that $s$ abnd $s'$ have the same white space normal form.
Conversely, the reader inversts the printer in the sense that, if syntax tree $x$ can be represented by a string, then printing $x$ and reading the result gives back $x$.
However, there are syntax trees which cannot be represented by a string.  For example we have that "+" is lower precidence than * and hence the tree
\begin{verbatim}
     *
    / \
   a   +
      / \
     b   c
\end{verbatim}
cannot be represneted by a string. It can, however, be created with {\tt `\{a * \$x\}} where $x$ is the result of reading {\mtt b + c}.
Note that parsing {\tt a * (b + c)} results in the tree
\begin{verbatim}
     *
    / \
   a   (.)
        |
        +
       / \
      b   c
\end{verbatim}
which is different.

It is often more natural to think in terms of strings where tree structure exists only to disambiguate
pattern matching in case expressions.  When constructing expressions with backquote it is aften advisable to insert
parentheses around inserted values to ensure that the resulting expression is string-representable.  For example,
rather than write {\tt `\{a * \$x\}} one should write {\tt `\{a * (\$x)\}}.
\end{document}
