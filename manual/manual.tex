\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{psfrag}
\usepackage{color}

\newcommand{\mtt}[1]{\mbox{\tt #1}}
\input /users/davidmcallester/03/tex/nofill.tex

\newcommand{\fopen}{{\color{red} \langle}}
\newcommand{\fclose}{{\color{red} \rangle}}

\newcommand{\ignore}[1]{}

\parskip = 2ex
\newcommand{\context}{\text{\emph{context}}}

\title{MetaC}
\author{David McAllester}

\begin{document}
\maketitle

\begin{abstract}
  MetaC is a Lisp-inspired programming environment for C. MetaC provides a read-eval-print loop (REPL) capable of evaluating (compiling and running)
  C statements and expressions.  The REPL is capable of incremental procedure definition and redefinition (dynamic linking).  MetaC also provides
  a macro feature similar to that of Lisp and powerful symbolic programming features for writing computed macros.  Most of the symbolic programming features of
  MetaC are implemented as bootstrapped MetaC macros.  MetaC is intended to be a development environment for frameworks implemented as
  macro packages. Frameworks written in MetaC (and MetaC itself) use a universal algebraic concrete syntax (UACSS) ---
  a simplification of the C concrete syntax but based on the Lisp philosophy that a single concrete syntax suffices for a wide variety of languages with
  a wide variety of semantics.  MetaC macro packages
  should be viewed as compilers from framework expressions to C code.  MetaC gives the framework developer complete control over the C code
  generated for framework expressions.  Frameworks written in MetaC inherit the REPL and gâ€ eneral programming environment of MetaC.
\end{abstract}

\section{Introduction and Overview}

We start with hello world.

\subsection{Hello World}

Once one has cloned the MetaC repository (git@github.com:mcallester/MetaC.git) one can cd to the repository directory and type 

\begin{verbatim}
bash$ make MC
...

basth$ MC

MC>
\end{verbatim}

We can then evaluate a hello world expression.

\begin{verbatim}
MC> `{hello world}

hello world

MC>
\end{verbatim}

In the above example the backquote expression given to the REPL macro-expands to a C expression which evaluates to the expression ``hello world''.
Backquote is described in more detail below.

\subsection{C Statements, C expressions, and UACS Expressions}

We can also declare global variables and execute statements from the REPL.

\begin{verbatim}
MC> int x[10];

done

MC> for(int i = 0; i < 10; i++)x[i] = i;

done


MC> for(int i = 0; i < 10; i++)fprintf(stdout,"%d",x[i]);

0123456789done

MC>int_exp(x[5])

5

MC>
\end{verbatim}

In C syntax one distinguishes C expressions from C statements.  A C
statement is executed for effect while a C expression is evaluated for
value. The REPL can be given either a statement or an expression.  When
given a C statement, the REPL simply prints ``done'' after executing
the statement.
When given a C expression the REPL computes and prints
the value.  The REPL assumes that the value of a C expression
is a UACS tree (also called a UACS expression giving a second, and confusing,
sense of the term ``expression''). The procedure {\tt int\_exp} above
converts an integer to a UACS expression.  UACS expressions are abstract
syntax trees but can viewed as representations of strings.

If a C statement executes a {\tt return} outside of any
procedure then that value is returned to the REPL and printed.
For example, the above session can be extended with the following.

\begin{verbatim}
MC>{int sum = 0; for(int i = 0; i < 10; i++)sum += x[i]; return int_exp(sum);}

45

MC>
\end{verbatim}

\subsection{Definitions of Types and Procedures}

One can also define new data types and procedures from the REPL.

\begin{verbatim}

MC> typedef struct expliststruct{
      expptr car;
      struct expliststruct * cdr;
    } expliststruct, *explist;

done

MC> explist mycons(expptr x, explist l){
      explist cell = malloc(sizeof(expliststruct));
      cell->car = x;
      cell->cdr = l;
      return cell;}

done

MC> expptr list_exp(explist l){
     if(l == NULL) return NULL;
     return `{ ${l->car} ${list_exp(l->cdr)} };
}

done

MC> list_exp(mycons(`{foo},mycons(`{bar},NULL)))

foo bar

MC>
\end{verbatim}

Procedures can also be redefined at the REPL provided that the
signature (argument types and return type) remains the same.  In the
current implementation (June 5, 2018) changing a procedure signature
requires restarting the MetaC REPL.  This restricting ensures
meaningful C type checking in the presence of dynamic linking.

\subsection{The Global Variable Array Restriction}

To simplify dynamaic linking, all global data
variables must be arrays. One can always use single element
arrays to represent non-array variables.  To make this more convenient
we allow single element arrays to be declared with an initial value in a
manner similar to non-array data variables.  For example, we can declare and assign a variable {\tt y}
as follows.

\begin{verbatim}
MC> int y[0] = 2;

done

MC> y[0] += 1;

done

MC> int_exp(y[0])

3

MC>
\end{verbatim}

Here assignments to $y[0]$ are allowed but assignments to $y$ are not --- assignment to array variables
are not allowed in $C$. As noted above, this restriction greatly simplifies dynamic linking of data variables.

\subsection{The Single Symbol Type Restriction}

To simplify the implementation of MetaC all type expressions appearing in procedure signatures and global array declarations must be single symbols.
Arbitrary types can be given single symbol names using {\tt typedef}.

\subsection{Backquote and UACS Expression Trees}

We now consider backquote and UACS expressions in more detail.  Backquote can be used in a manner analogous to string formatting.

\begin{verbatim}
MC> expptr friend[0] = `{Bob Givan};

done

MC> int height[0] = 6;

done

MC> `{My friend ${friend[0]} is ${int_exp(height[0])} feet tall.}

My friend Bob Givan is 6 feet tall.

MC> 
\end{verbatim}

While UACS expressions can be viewed as representations of strings, UACS
expressions are actually abstract syntax trees. The tree structure
plays an important role in pattern matching. The tree structure is
more apparent in the following example.

\begin{verbatim}
MC> expptr x[0] = `{a+b};

done

MC> `{bar(${x[0]})}

bar(a+b)

MC>
\end{verbatim}

As described in the next section, the pattern {\tt foo(!x)} will match the expression {\tt foo(a+b)} with {\tt x} bound to the expression (tree) {\tt a+b}.

\subsection{Pattern Matching}

MetaC provides a pattern matching case statement.
The general form of the case construct is the following.

\begin{verbatim}
ucase{e;
  {<pattern1>}:{<body1>}
   ...
  {<patternn>}:{<bodyn>}}
\end{verbatim}

Variables are marked in patterns by the symbol tags {\tt !} and {\tt ?}.  The variable {\tt !x} can match any expression while {\tt ?x} can only match symbols (or other lexicalized
tokens without internal structure as described in section~\ref{sec:lex}).

\begin{verbatim}
MC> int value(expptr e){
      ucase{e;
        {!x+!y}:{return value(x)+value(y);}
        {!x*!y}:{return value(x)*value(y);}
        {(!x)}:{return value(x);}
        {!z}:{return symbol_int(z);}}
     return 0;
   }

done

MC>value(`{3+(2*5)})

30

MC>
\end{verbatim}

In many cases the choice of the particular tree structure imposed by the MetaC reader is unimportant.  For example, the expression {\tt a+b+c} will match the pattern
{\tt !x+!y+!z} independent of whether + is left associative or right associative.  But the tree structure does matter in other cases.  The pattern {\tt !x*!y}
will not match the expression {\tt a+b*c} because the reader brackets {\tt a+b*c} as  $\fopen \mathtt{a~+} \fopen \mathtt{b * c} \fclose\fclose$. The pattern {\tt !x*!y} does match {\tt (a+b)*c}.

As of June 2018 repeated variables, such as in the pattern {\tt \{!x + !x\}}, are not supported (and not checked for).
If a variable is repeated it will be matched at its last occurrences under depth-first left to right traversal.

\subsection{Gensym and Macro Definitions}

MetaC supports computed macros which can exploit pattern matching, backquote pattern instantiation, and other (bootstrapped) high level language features.
As a very simple example we can define a {\tt dolist} macro at the REPL.

\begin{verbatim}
MC> umacro{mydolist(!x, !L){!body}}{
     expptr rest = gensym(`{rest});
     return `{for(explist ${rest} = ${L};
                  ${rest} != NULL;
                  ${rest} = ${rest}->cdr;)
               {expptr ${x} = ${rest}->car; ${body}}}}

done

MC>macroexpand(`{dolist(item,list){f(item);}})

for(explist _mcgen_rest1=list; _mcgen_rest1 !=NULL; _mcgen_rest1=_mcgen_rest1->cdr;)
    {expptr item=_mcgen_rest1->car;
     f(item);}

MC>
\end{verbatim}

The general form of a macro definition is
\begin{verbatim}
umacro{<pattern>}{<body>}
\end{verbatim}
where instances of {\tt <pattern>} in MetaC code are to be replaced by the value returned by {\tt <body>} under the variable bindings determined by the match.
The procedure {\tt macroexpand} takes a UACS expression
and returns the result of repeatedly expanding outermost macros until no further macro expansion is possible.  Macro expansion can generate effects as well as return an expansion.  The REPL performs
macro expansion on the given expression and also performs the effects of that expansion.  {\tt umacro} is itself a MetaC macro and we can feed the above macro definition to the REPL.

The macro expansion of the above macro definition defines a procedure to compute the macro expansion and installs that procedure on a macro property of the symbol {\tt mydolist}.
In a typical use a macro patterns is a symbol followed by a sequence of parenthesis expressions., in which case the expansion procedure is attached to the given symbol,
or generalized application expression or a binary connection expressions.  UACS expression types are discussed in the next section.
The procedure for macro expansion is attached to either the head symbol of the application
or the binary operator of the binary connection expression.

\section{Universal Algebraic Concrete Syntax (UACS)}

It is not obvious how to implement light weight expression quotation and expression pattern matching for C expressions.  The syntax of C is complex.
We bypass this complexity by introducing universal algebraic concrete syntax (UACS). UACS is ``universal'' in that it has the following three properties.

\begin{enumerate}
\item UACS syntax trees are semantics-free.  They are simply trees viewed as representations of character strings.

\item The UACS reader can read any parenthesis-balanced character string.
  Here parenthesis-balanced means that every open parenthesis, brace or bracket has a matching closing character and that string quotations
  are properly closed.
  
\item The printer inverts the reader. If we read a string $s$ into a UACS expression
  $e$ and then print $e$ back into a string $s'$ we have that $s$ and $s'$ are ``whitespace equivalent'' as defined in section~\ref{sec:lex}.
  This implies that $s$ and $s'$ will be treated equivalently by the C compiler.
\end{enumerate}

The emphasis here is on the representation of strings.  The reader does not always invert the printer ---
the expression $\fopen \fopen \mathtt{one~two} \fclose \;\mathtt{three}\fclose$ prints as {\tt one two three} which reads as
$\fopen \mathtt{one}\; \fopen \mathtt{two~three} \fclose \fclose$.  But the represented string is preserved.  This is fundamentally different from
most programming languages supporting symbolic computation (such as Lisp) where it is assumed that the reader should invert the printer.

The above universality properties allow one to assign semantics to UACS expressions based on the strings that they represent.  We can assign C
semantics to an expression by printing the expression and passing the resulting string to a C compiler.  This string-based semantics is not always
compositional with respect to the UACS bracketing.  However, the tree structure imposed by the reader is designed to approximate the
compositional structure of C syntax.  In most cases pattern matching on UACS expressions recovers substructure that is semantically meaningful under C
semantics. Parentheses and semicolons are particularly helpful in aligning UACS trees with C syntax.

\subsection{Comment Removal, Segmentation and Lexicalization}
\label{sec:lex}

The MetaC preprocessor removes C-style comments and divides files into segments where each segment is to be read as a separate expression.
A new segment starts at the beginning of any line whose first character is not a space, tab or close character (right parenthesis, brace or bracket).
A file must be parenthesis-balanced within each segment.
For the REPL a segment ends at the first return character not occurring inside parentheses.

Lexicalization segments a pre-processed into to a sequence of character strings. The UACS lexer preserves all non-white characters.  For UACS lexer the strings in lexicalized sequence are classified into
the following types.

\begin{itemize}
\item Symbols,  A symbol is a character string consisting of only alpha-numeric characters --- upper and lower case letters of the alphabet, plus the decimal numerals, plus underbar.
  For example {\tt foo\_bar1}.
\item Connectives.  A connective is a character string consisting of only ``connective characters'' --- the characters comma,
  colon, semicolon, {\tt =}, {\tt $\sim$}, {\tt $<$}, {\tt $>$}, \mtt{|}, {\tt \&}, {\tt +}, {\tt -}, {\tt *}, {\tt /}, {\tt .}, {\tt @}, \mtt{$\hat{~}$}.
  For example the strings {\tt ->} and {\tt ==}.
\item Quoted strings.  A character string starting and ending with the same string quotation character.  For example {\tt "foo bar"}, {\tt "!:\&?;"} or {\tt 'a'}.
\item Misc characters.  These are non-white single characters other than those mentioned above and other than parenthesis characters.  In particular, one of the characters
  {\tt \$}, {\tt $\backslash$}, {\tt `}, {\tt !}, {\tt ?}, {\tt \#} and {\tt \%}.
\end{itemize}


The UACS lexicalization preserves all quoted character strings and all non-white characters outside of string quotation.  Two strings are called whitespace-equivalent
if they lexicalize to the same sequence.  For many strings $s$ we have that $s'$ is whitespace equivalent to $s$ if and only if $s$ and $s'$ have the same sequence
of non-white characters.
Two strings that lexicalize equivalently under the UACS lexer will also lexicalize equivalently under the C lexer although the C lexicalization may be different from
that of the UACS lexicalization.  Ultimately an unlexicalized character string is passed from MetaC to the C compiler. The MetaC programmer should keep in mind the
character strings that UACS expressions represent.

\subsection{UACS Expressions: cons-car-cdr}

A UACS expression is either an atom (a lexical item character string),
a pair $\fopen e_1 e_2 \fclose$ where $e_1$ and $e_2$ are expressions, or a ``parenthesis expression'' the form $(e)$,
$\{ e\}$, or $[e]$ where $e$ is an expression.  A cons-car-dcr interface to expressions can be implemented as follows.

\begin{verbatim}
expptr cons(expptr x, expptr y){return `{${x} ${y}};}

expptr car(expptr cell){
  ucase{cell;
         {!x !y}:{return x;}}}

expptr cdr(expptr cell){
  ucase{cell;
         {!x !y}:{return y;}}}

expptr add_parens(expptr e){return `{(${e})};}

expptr inside(expptr parens){
  ucase(parens;
        {(!e)}:{return e;}}}

int atomp(expptr s){
    ucase{s;
          {?s}:{return 1;}
          {!x}:{return 0;}}}
\end{verbatim}

As part of this interface we can convert an atom (or any expression) to a C string with the MetaC procedure {\tt exp\_string}.
The procedure {\tt exp\_atring} is a version of the MetaC printer.

\subsection{UACS Expressions: Phantom Brackets}

A UACS expression can be represented by ``phantom brackets'' where there is a pair of brackets for each pair expression (cons cell).
For example the expression \mtt{\{one two three\}} reads as $\{\fopen \mathtt{one}\;\fopen \mathtt{two~three}\fclose \fclose\}$.
To reduce the clutter of brackets we will adopt the Lisp convention of not showing all the cell brackets for right-associative sequences (lists).
For example $\fopen \mathtt{zero}\;\fopen \mathtt{one}\;\fopen \mathtt{two~three}\fclose \fclose \fclose$.
will be written as $\fopen\mathtt{zero~one~two~three}\fclose$.  Note that these ``lists'' are atom-terminated rather than the Lisp convention of
nil termination. We will also often write $\fopen \fopen a_1 \;o\fclose\;a_2\fclose$ where $o$ is a connective atom
as $\fopen a_1\;o\;a_2 \fclose$.  For example, the expression \mtt{\{a + b\}} reads as
$\{\fopen \fopen \mathtt{a~+} \fclose \;\mathtt{b} \fclose \}$ which is then abbreviated as
$\{\fopen \mathtt{a~+~b} \fclose \}$.  Left-association for binary connectives gives a
C-consistent treatment of semicolon as a binary connective while supporting expressions of the form $\fopen e \;;\fclose$.
It will generally be clear from context which abbreviation is being used.
A set of examples of strings and the phantom brackets generated by the reader is given in figure~\ref{fig:reader}.
The printer simply removes the phantom brackets and prints the string that the expression represents.

To emphasize the significance of left-association for binary connectives we note that
the UACS reader bracketing of
$$\{e_1\;;\;e_2\;;\;e_3\;;\}$$
can be written using either the binary connective convention as
$$\{\fopen e_1\;;\;\fopen e_2\;;\;\fopen e_3\;;\fclose\fclose\fclose\}$$
or the right-associative sequence convention as
$$\{\fopen \fopen e_1\;;\fclose \;\fopen e_2\;;\fclose \;\fopen e_3\;;\fclose\fclose\},$$
both of which abbreviate the same full bracketing
$$\{\fopen \fopen e_1\;;\fclose \;\fopen \fopen e_2\;;\fclose \;\fopen e_3\;;\fclose\fclose\fclose\}.$$
Hence the string {\tt (a\;;\;b\;;)} matches both the pattern
the pattern $\{(!x\;!y)\}$ with $x$ bound to $\fopen a\;;\fclose$ and $y$ bound to $\fopen\mathtt{b}\;;\fclose$,
and also matched  $\{(!x\;;\;!y)\}$ with $x$ bound to {\tt a} and $y$ bound to  $\fopen\mathtt{b}\;;\fclose$.

\begin{figure}
\begin{eqnarray*}
  \mathtt{Hello~World} & \Rightarrow & \fopen \mathtt{Hello}\;\; \mathtt{World}\fclose \\
  \mathtt{one~two~three} & \Rightarrow & \fopen \mathtt{one}\;\; \fopen \mathtt{two} \; \;\mathtt{three}\fclose\fclose \\
   & = & \fopen \mathtt{one~two~three} \fclose \\
  \mathtt{x~+~y} & \Rightarrow & \fopen\fopen \mathtt{x~+}\fclose\;\mathtt{y}\fclose \\
  & = & \fopen \mathtt{x~+~y} \fclose \\
  \mathtt{x+y*z} & \Rightarrow & \fopen \mathtt{x~+}\; \fopen \mathtt{y~*~z} \fclose\fclose \\
  \mathtt{(x+y)*z} & \Rightarrow & \fopen (\fopen \mathtt{x~+~y} \fclose )\;\mathtt{*~z}\fclose \\
  \mathtt{foo}(\mathtt{int~x}) & \Rightarrow & \fopen \mathtt{foo}\; (\fopen \mathtt{int}\;  \; \mathtt{x}\fclose)\fclose \\
  \mathtt{foo(int~x,~float~y)} & \Rightarrow & \fopen \mathtt{foo} \; (\fopen\fopen\fopen \mathtt{int}\; \mathtt{x}\fclose\;
  \mathtt{,}\fclose\; \fopen\mathtt{float} \; \mathtt{y} \fclose\fclose )\;\fclose \\ 
  ?\mathtt{f}(\mathtt{!args}) & \Rightarrow & \fopen\;\fopen?\;\mathtt{f}\fclose\; (\fopen \mathtt{!} \;\mathtt{args}\fclose)\;\fclose \\
  \backslash \$\{\mathtt{x}\} & \Rightarrow & \fopen \backslash\;\; \fopen\$ \;\;\{\mathtt{x}\}\fclose\fclose
\end{eqnarray*}

\caption{{\bf Examples of Reader Bracketings.} Bracketings are shown for the expression that results form reading the given strings.
  A complete bracketing shows a pair of brackets for every expression pair (cons cell).
  The second and third example show two somewhat informal conventions for dropping some of the brackets --- general sequences are
  assumed to be right-associative and binary connective applications are assumed to be left-associative.  These conventions are used in other examples.
  Expressions are printed without the brackets --- the brackets are ``phantoms'' that show the tree structure.   The bracketing (parsing) done by the reader
  is specified formally in section~\ref{sec:reader}. Since the bracketing does not affect the represented string, the precise bracketing is often unimportant.}
\label{fig:reader}
\end{figure}

\subsection{Backquote and Pattern Matching Revisited}

The semantics of backquote is defined in terms of cons-car-cdr view of UACS expressions independent of the UACS reader.
In the typical case, the C value of a backquote expression
$\fopen ` \;\{e\}\fclose$ is the expression $e$ with subexpressions of the form $\fopen \$\;\{w\}\fclose$ replaced by the expression which is the C value of the string represented by the expression $w$.

Unfortunately this evaluation rule for backquote expressions is incomplete.  One of the most
confusing situations is where the expansion of a macro contains a backquote.  Writing such a macro typically involves nested backquotes.  While nested backquotes
are confusing, and should be avoided when possible, MetaC supports nested backquotes.  We consider a series of backquote expressions each of which evaluates to the previous one.

First we have
\begin{equation}
\label{bq1}
`\{a+b+\$\{z\}\}
\end{equation}

If the value of variable {\tt z} is the expression {\tt c} then the value of expression (\ref{bq1}) is the expression {\tt a+b+c}.
The symbol {\tt \$} can be included in the value of a backquote expression by quoting it.  This gives our second expression.
\begin{equation}
\label{bq2}
`\{`\{a + \$\{y\} + \backslash\$\{z\}\}\}
\end{equation}
If the value of variable {\tt y} is the expression $b$ then the value expression of (\ref{bq2}) is expression (\ref{bq1}).
We can even have multiple layers of quotation as in the following.
\begin{equation}
\label{bq3}
`\{`\{`\{\$\{x\} + \backslash\$\{y\} + \backslash\backslash\$\{z\}\}\}\}
\end{equation}
If the value of variable {\tt x} is the expression {\tt a} then the value of expression (\ref{bq3}) is expression (\ref{bq2}).

As with backquote, pattern matching is defined in terms of the cons-car-cdr view of expressions independent of the UACS reader.  We define a substitution to be a mapping from
symbol atoms to expressions. For a substitution $\sigma$ and a pattern $\{e\}$ we define the expressions $\sigma(e)$
to be the result of replacing each subexpression of $e$ of the form $\fopen !\;x \fclose$ where $x$ is a symbol atom with $\sigma(x)$ and each subexpression of the form
$\fopen ?\;x \fclose$ where $x$ is a symbol atom by $\sigma(x)$ provided that $\sigma(x)$ is an atom.  A pattern $\{e\}$ matches an expression $w$ with substitution $\sigma$
if $\sigma(e) = w$. An exception to this is the case where a variable occurs multiple times in the pattern.  As of June 2018 multiple occurrences of a variable in a pattern is not supported.

\subsection{The Reader Specification}
\label{sec:reader}

\newcommand{\sym}{\mathrm{SYM}}
\newcommand{\conn}{\mathrm{CONN}}
\newcommand{\quot}{\mathrm{QUOTE}}
\newcommand{\misc}{\mathrm{MISC}}
\newcommand{\gatom}{\mathrm{GATOM}}
\newcommand{\argg}{\mathrm{ARG}}
\newcommand{\e}{\mathrm{E}}
\newcommand{\paren}{\mathrm{PAREN}}
\newcommand{\foo}{\mathtt{foo}}
\newcommand{\barr}{\mathtt{bar}}
  
We now give a grammar specifying the UACS reader.  We also attempt to describe the reader in an intelligible way independent of the formal grammar.
The grammar will define a linear-time deterministic shift-reduce parsing process.

To read a string $s$ it will be convenient to enclose $s$ in parenthesis and read the string $(s)$.  This gives the reader access to ``endpoint tokens'' marking the beginning and end of the string.
Reading $(s)$ results in a parenthesis expression $(e)$ where the string $s$ is read as the expression $e$.

The grammar uses nonterminals
$\sym$, $\conn$, $\quot$ and $\misc$ to range over symbol atoms (alphanumeric strings), binary connective atoms (strings over the connective symbols), quoted string atoms, and
the miscellaneous character atoms respectively.  There is also a nonterminal $\paren$ to range over parenthesis expressions.


The UACS reader has the property that a string of the form {\tt $\$$\{...\}} always reads to a single expression of the form $\fopen \$\;\{e\}\fclose$ independent of the context in which the string appears.
The general rule is that any sequence of the miscellaneous characters followed by either a symbol atom, a string quotation atom, or a parenthesis expression reads as a single expression independent of context.
A sequence of miscellaneous characters followed a close character or a connective atom also reads as a single expression.  The reader grammar has a nonterminal $\gatom$, for generalized atom, ranging over
this class of expressions. This definition of the range of the nonterminal $\gatom$ can be expressed by the following context-sensitive grammar rules
where the close character can be interpreted as any of the three parenthesis expression closing characters.
\begin{eqnarray*}
  \gatom & \rightarrow & \sym \;\;|\;\; \quot \;\;|\;\; \paren \;\;|\;\; \misc\;\gatom \\
  \gatom\;) & \rightarrow & \misc\;) \\
  \gatom\; \conn & \rightarrow & \misc\; \conn \\
\end{eqnarray*}
Note that any occurrence of a miscellaneous character is contained in some $\gatom$ expression.

There is also has a nonterminal $\argg$ that ranges over sequences of $\gatom$'s that are followed by a binary connective or a closed parenthesis character.
This is defined by the following grammar.
\begin{eqnarray*}
  \argg\;) & \rightarrow & \gatom\;) \\
  \argg\; \conn & \rightarrow & \gatom\; \conn \\
  \argg & \rightarrow & \gatom \; \argg
\end{eqnarray*}
The string {\tt (!x !y)} is now deterministically parsed as $(\gatom\; \gatom)$ and then as $(\argg)$.  The string $(f(x) + !y)$ is now
parsed as $(\gatom\;\gatom\; +\; \gatom)$ and then as $(\argg\; + \;\argg)$.

We now consider the problem of parsing a sequence of arguments and connectives.  We first consider the normal case
where the sequence alternates arguments and connectives and starts and ends with arguments.
The more general case is considered below (we are requiring that we be able to parse any string).

Each connective atom is associated with a precedence and each precedence level is associated with a convention for being left-associative or right associative.
Grouped by precedence, the binary connective characters are

\medskip
\centerline{\{semicolon\} \{comma\}  \{$\hat{\mathtt{~}}$\}
  \{\mtt{|}, {\tt \&}\} \{{\tt =}, {\tt $\sim$}, {\tt $<$}, {\tt $>$}\} \{{\tt +}, {\tt -}\} \{{\tt *}, {\tt /}\} \{{\tt \%}\} \{{\tt .}, colon,  {\tt @}\}.}

The precedence of a binary connective is determined by its first character.  The characters have low to high (outer to inner) precedence in the order given with symbols
in the same group having the same precedence.  The precedence can be summarized in outer to inner order as semicolon, comma, an expression separator below comma,
Boolean connectives, binary predicates,
four levels of binary functions, and ``symbol connectives'' --- ways of building compound symbols.  Below the level of parentheses, semicolon and comma the UACS precedence
conventions have various divergences with C syntax.  However, when writing a macro package in MetaC one can simply adopt the MetaC precedence conventions for the
source code and use parentheses where necessary in the generated C code.


To be able to parse any string we intuitively add a phantom argument between each pair of adjacent binary connectives and also add a phantom argument
at the beginning if the string starts with a connective and a phantom argument at the end if the string ends with a connective.
This determines a parse tree which may contain phantom arguments.  The phantom argument are then removed by replacing any cell with a phantom argument by the non-phantom sibling.
This gives the following readings.
\begin{eqnarray*}
\mathtt{(x~+~*~y)} & \Rightarrow & (\fopen\mtt{x~+}\;\fopen \mathtt{*~y}\fclose \fclose) \\
\mathtt{(x~*~+~y)} & \Rightarrow & (\fopen\fopen\mtt{x~*} \fclose\;+\;\mathtt{y}\fclose) \\
\mathtt{(+~a~+~b)} & \Rightarrow & (\fopen \mathtt{+}\;\fopen \mathtt{a~+b}\fclose\fclose) \\
\mathtt{(a~+~b~+)} & \Rightarrow & (\fopen \mathtt{a~+}\;\fopen \mathtt{b~+}\fclose\fclose) \\
\mathtt{(a~;~b~;)} & \Rightarrow & (\fopen \mathtt{a~;}\;\fopen \mathtt{b~;}\fclose\fclose) \\
& = & (\fopen \fopen \mathtt{a~;}\fclose\;\fopen \mathtt{b~;}\fclose\fclose)\end{eqnarray*}
Parsing sequences of arguments and connectives with precedence and associativity conventions should be
familiar.  However, for completeness, and to handle subtleties of phantom arguments,
We give grammar rules. We will let $\conn_p$ be a nonterminal ranging over
connectives with precedence $p$ and let $\e_p$ be a nonterminal ranging over
expressions containing connectives where $p$ is the lowest precedence of any connective in the expression.
We let $\tilde{\e}_p$ be a nonterminal ranging over expressions
of the form $\fopen e\;o\fclose$ with $\e_p \rightarrow^* e$ and $o$ is a connective with precedence $q$ where $q > p$ or $q = p$ with $p$ being a left associative precedence.
The grammar rules for the case where all arguments are explicit can be written as
\begin{eqnarray*}
 (\;\tilde{\e}_p  & \rightarrow &   (\;\argg \; \conn_p \\
  \tilde{\e}_p \;\tilde{\e}_q & \rightarrow & \tilde{\e}_p \;\argg \;\conn_q\;\;\mbox{for $q > p$ or $q= p$ and $p$ right associative} \\
  \e_p \;\conn_q & \rightarrow & \tilde{\e}_p \;\argg \;\conn_q \;\;\mbox{for $q < p$ or $q= p$ and $p$ left associative} \\
  \e_p\;) &\rightarrow & \tilde{\e}_p \;\argg)
\end{eqnarray*}
Phantom arguments are handled by the following rules which also define a deterministic parsing algorithm.
\begin{eqnarray*}
   (\;\tilde{\e}_p  & \rightarrow &   (\; \conn_p \\
  \tilde{\e}_p \;\tilde{\e}_q & \rightarrow & \tilde{\e}_p  \;\conn_q\;\;\mbox{for $q > p$ or $q= p$ and $p$ right associative} \\
  \e_p \;\conn_q & \rightarrow & \tilde{\e}_p \;\conn_q \;\;\mbox{for $q < p$ or $q= p$ and $p$ left associative} \\
    \e_p\;) &\rightarrow & \tilde{\e}_p)
\end{eqnarray*}

Finally we have
$$\paren \Rightarrow (\e_p) \;\;|\;\; (\argg)\;\;| \;\;()$$
where analogous rules hold for the other parethesis characters as well.  The empty parenthesis expression contains the atom for the empty string.
In the implementation the empty string is denoted by {\tt nil} which is also used as a general list terminator.

The system of rules presented in this section define a linear time deterministic shift-reduce parsing process.
\end{document}
