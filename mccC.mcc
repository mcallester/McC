#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <math.h>
#include <setjmp.h>
#include <time.h>
#include <dlfcn.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/file.h>
#include <fcntl.h>
#include "mcc.h"

/** ========================================================================
catch-return{type,statement}

This is an expression where the statement returns a value of the stated type.
========================================================================**/

expptr replace_returns(expptr var, expptr donelabel, expptr s){
  ucase{s;
    {return(!e)}:{
      return `{{$var = $e; goto $donelabel;}};}
    {!x}:{
      if(atomp(s)) return s;
      return intern_exp(constructor(s),
			replace_returns(var, donelabel, arg1(s)),
			replace_returns(var, donelabel, arg2(s)));}}
  return NULL;
}

umacro{catch_return{!type, {!statement}}{
    expptr result = gensym(`result);
    expptr donelabel = gensym(`done);
    return `{({
	  $type $result;
	  $replace_returns(result,donelabel,statement)
	    $donelabel: $result;})};
  }
}


/** ========================================================================
Lists.  We represent a list if exoressions x1, x2, ..., xn by the expression {x1},{x2}, ... ,{xn},nil.
This guarantees that list expression is properly represented by its print string  --- is print-invertable
--- provided that each xi is print-invertable.
========================================================================**/

umacro{push{!x,!y}{
  if(!symbolp(y))berror("illegal syntax in push");
  return `{$y = cons($x,$y)};
  }
}

umacro{dolist{{!x,!y}{!body}}{
    expptr yval = gensym(`yval);
    expptr rest = gensym(`rest);
    return `{{
	expptr $yval = $y;
	while($yval != nil){
	  ucase{$yval;
	    {{!$x}, !$rest}:{
	      {$body}
	      $yval = $rest;}}}}};
  }
}

umacro{mapc(!f,!list){
    expptr x = gensym(`x);
    return `{dolist{{$x, $list}{$#f($x);}}};
  }
}

expptr mapcar(expptr f(expptr), expptr l){
  if(l == nil) return nil;
  ucase{l;
    {{!first},!rest}:{
      return `{{$f(first)},$mapcar(f,rest)};}}
  return `void;
}
      
/** ========================================================================
file_expressions
========================================================================**/

expptr file_exps_helper(){
  if(readchar == EOF) return nil;
  expptr next = read_from_file();
  if(next == NULL){return file_exps_helper();}
  return cons(next, file_exps_helper());
}

expptr file_expressions(expptr fname){
  open_input_file(exp_string(fname));
  expptr result = file_exps_helper();
  fclose(fileout);
  return result;
}


/** ========================================================================
A nice string format macro
========================================================================**/

//warning --- this replicates the arguments and hence the arguments should be variables.
//this is hard to fix because the argument types are very difficult to determine.

umacro{sformat(!args){
    return `{
      catch_return{charptr, {
	  int needed_size = snprintf(NULL,0,$args);
	  char * buffer = (char *) stack_alloc(needed_size+1);
	  sprintf(buffer,$args);
	  return(buffer);}}};
  }
}

/** ========================================================================
stack frames for the debugger;
========================================================================**/
void sframe_error();
expptr args_struct(expptr args);
expptr stack_frame_code(expptr frame_ptr_type, expptr frame_struct_type, expptr f, expptr args);
expptr install_args_code(expptr framevar, expptr args);

umacro{sframe(!type !f(!args){!body}){
    if(!symbolp(f))uerror(`{
	(illegal syntax in sframe)
	  ($f is not a symbol in ($type $#f($args)))});
    expptr frame_ptr_type = gensym(`frame_ptr_type);
    expptr frame_struct_type = gensym(`frame_struct_type);
    add_preamble(`{typedef struct {expptr fname; struct {$args_struct(args)} args;}$frame_struct_type, * $frame_ptr_type;});
    if(type == `void){
      return `{$type $#f($args){
	  $stack_frame_code(frame_ptr_type,frame_struct_type,f,args);
	  $body;
	  pop_stack_frame();}};}
    else{
      expptr g = gensym(`body_fun);
      expptr result = gensym(`result);
      add_preamble(`{$type $#g($args){$body}});
      return `{
	$type $#f($args){
	  $stack_frame_code(frame_ptr_type,frame_struct_type,f,args);
	  $type $result = $#g($args_variables(args));
	  pop_stack_frame();
	  return $result;}};}}
}

expptr args_struct(expptr args){
  ucase{args;
    {!type !var, !rest}:{
      if (!symbolp(var)) sframe_error(args);
      return `{$type $var; $args_struct(rest)};}
    {!type !var}:{
      if (!symbolp(var))sframe_error(args);
      return `{$type $var;};}
    {!x}:{
      sframe_error(args);
      return `void;
    }
  }
}

expptr stack_frame_code(expptr frame_ptr_type, expptr frame_struct_type, expptr f, expptr args){
  
  expptr framestruct = gensym(`framestruct);
  expptr bq_cache = gensym(`backquote_cache);
  add_preamble(`{expptr $#bq_cache[1];});
  add_init_form(`{* $bq_cache = `$f;});
  add_init_form(`{setprop(`$f,`frametype,`$frame_ptr_type);});
  return `{
    $frame_ptr_type $framestruct = ($frame_ptr_type) stack_alloc(sizeof($frame_struct_type));
    $framestruct->fname = * $bq_cache;
    $install_args_code(framestruct, args);
    push_stack_frame2($framestruct);};
}

expptr install_args_code(expptr framevar, expptr args){
  ucase{args;
    {!type !var, !rest}:{
      return `{$framevar->args.$var = $var; $install_args_code(framevar,rest);};}
    {!type !var}:{
      return `{$framevar->args.$var = $var;};}}
  return `void;
}

expptr args_variables(expptr args){
  ucase{args;
    {}:{return `{};}
    {!type !var(!types), !rest}:{return `{$var, $args_variables(rest)};}
    {!type !var(!types)}:{return var;}
    {!type !var, !rest}:{return `{$var, $args_variables(rest)};}
    {!type !var}:{return var;}
    {!x}:{uerror(`{the argument list $args should use only single-symbol types});}}
  return NULL;
}

void sframe_error(expptr args){
  {uerror(`{
	(argument list syntax)
	  ($args)
	  (not recognized by sframe)
	  (types should be single symbols)});}
}

initfun(mccD_init)



 

  
